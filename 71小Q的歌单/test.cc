// 小Q有X首长度为A的不同的歌和Y首长度为B的不同的歌，现在小Q想用这些歌
// 组成一个总长度正好为K的歌单，每首歌最多只能在歌单出现一次，在不考虑
// 歌单内歌曲的先后顺序的情况下，情问有多少种组成方法？
//
// 输入描述:
// 每个输入包含一个测试用例。
// 每个测试用例的第一行包含一个整数，表示歌单的总长度K(1<=K<=1000)。
// 接下来的一行包含四个正整数，分别表示歌的第一种长度A(A<=10)和数量X(X<=100)以及歌的第二种长度B(B<=10)和数量Y(Y<=100)。保证A不等于B。
//
//
// 输出描述:
// 输出一个整数,表示组成歌单的方法取模。因为答案可能会很大,输出对1000000007取模的结果。
// 示例1
// 输入
// 5
// 2 3 3 3
// 输出
// 9

#include <iostream>

const int mod = 1000000007;

int a,x,b,y,k;
long long dp[1010];
int p[210];

int main(){
	while(std::cin >> k){
		std::cin >> a >> x >> b >> y;
		dp[0] = 1;
		for(int i = 1; i <= x; i++)
			p[i] = a;
		for(int i = x + 1; i <= x+y; i++)
			p[i] = b;

		for(int i = 1; i <= x+y; i++){
			for(int j = k; j >= p[i]; j--){
				dp[j] = (dp[j]%mod + dp[j - p[i]]%mod)%mod;
			}
		}
		std::cout << dp[k]%mod << std::endl;
	}
	return 0;
}
